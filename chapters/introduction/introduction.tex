
\chapter{Einleitung}

\nocite{*}
Rust ist eine moderne Multiparadigmen-Systemprogrammiersprache, die sich auf Sicherheit, Geschwindigkeit und Parallelität konzentriert. Sie entstand 2006 durch ein persönliches Projekt des Mozilla-Mitarbeiters Graydon Hoare und entwickelte sich im Laufe von fünf Jahren zu einem Open-Source-Projekt, das von Mozilla Research entwickelt wird und von einer großen Community von freiwilligen Mitwirkenden unterstützt wird.\autocite{heise-rust}\\
Rust ist die erste von der Industrie unterstützte Programmiersprache, die den seit langem bestehenden Kompromiss im Entwurf von Programmiersprachen zwischen den Sicherheitsgarantien höherer Programmiersprachen und der Kontrolle über die Speicherverwaltung durch low-level-Programmiersprachen überwindet. Höhere Programmiersprachen wie Java bieten zwar eine starke Typ- und Speichersicherheit und verhindern damit eine Vielzahl von Speicherfehlern, allerdings geht das auf Kosten der Ressourcenkontrolle. Infolgedessen besteht für viele Anwendungen der Systemprogrammierung die einzige realistische Option darin, eine Sprache wie \texttt{C} oder \texttt{C++} zu verwenden, die zwar eine fein granulierte Kontrolle über die Speicherverwaltung bietet, jedoch ist diese Kontrolle mit hohen Kosten verbunden. Beispielsweise berichtete Microsoft kürzlich, dass \texttt{70\%} der Sicherheitslücken, die sie beheben, auf Verletzungen der Speichersicherheit zurückzuführen sind,\autocite{microsoft-memory-safety-issues} also genau die Art von Verletzungen, die bei starken Typsystemen ausgeschlossen werden sollten.  Bekanntlich verwendet Microsoft hauptsächlich  \texttt{C} und \texttt{C++} für die Systemprorammierung. Ebenso berichtet Mozilla, dass die überwiegende Mehrheit der kritischen Fehler, die sie in Firefox finden, speicherbezogen sind.\autocite{mozilla-memory-safety-issues}

Rust geht diese Herausforderung mit Hilfe eines starken, neuartigen Typsystems an, das auf den Prinzipien der Ownership (Eigentümerschaft) und des Borrowing (Ausleihen) basiert und die Änderung von veränderlichen, statischen Variablen verbietet. Dieser Ansatz ermöglicht es, die üblichen Fallstricke der Systemprogrammierung wie Data Races zur Kompilierzeit zu erkennen und zu verhindern.

Das Ownership-System legt für jeden Wert eine klare Lebensdauer fest, wodurch die Verwendung eines Garbage-Collectors überflüssig wird und solide, aber flexible Schnittstellen für die Verwaltung anderer Arten von Ressourcen wie Sockets und Datei-Handles ermöglicht werden. Durch \glqq Moves\grqq{} können Werte von einem Eigentümer auf einen Anderen übertragen werden, und durch Ausleihen kann ein Wert vorübergehend verwendet werden, ohne dass sich dies auf das Eigentum auswirkt.

Die Kontrolle über die Speicherverwaltung ist ein sehr wichtiger Aspekt der systemnahen Programmierung, besonders für Anwendungen wie Web-Browser, Betriebssysteme oder Game-Engines, bei denen Leistungs- oder Ressourcenbeschränkungen ein Hauptanliegen sind. Dadurch, dass diese Art der Kontrolle von Rust unterstützt wird, wird die Möglichkeit geschaffen, die Darstellung von Daten auf Byte-Ebene zu bestimmen sowie einen Zugang zum \glqq Bare Metal\grqq{} zu schaffen und die zeitliche und räumliche Nutzung von Programmen durch Low-Level-Programmiertechniken zu optimieren.


Es gibt eine Reihe von Datentypen, deren Implementierungen grundlegend von veränderlichen, statischen Variablen abhängen und daher nicht nach dem strengen Ownership-Prinzip von Rust typgeprüft werden können. Um solche Datentypen zu unterstützen, setzt Rust auf die vernünftige Verwendung von unsicheren Codes (engl. Unsafe Code), welche optional in sicheren APIs gekapselt werden, um mehr sicherheit zu garanieren.\autocite{unsafe-rust}

Diese Alleinstellungsmerkmale, über die nur Rust verfügt, sind wohl der Grund, warum Rust von Entwicklern in einer 2020 von der Stack Overflow durchgeführten Umfrage zum fünften Mal in Folge zur beliebtesten Programmiersprache gewählt wurde.\autocite{stack-overflow-rust-most-loved}\autocite{why-rust-so-loved}