
\chapter{Einleitung}

\nocite{*}
Rust ist eine moderne Multiparadigmen-Systemprogrammiersprache, die sich auf Sicherheit, Geschwindigkeit und Parallelität konzentriert. Sie entstand 2006 durch ein persönliches Projekt des Mozilla-Mitarbeiters Graydon Hoare und entwickelte sich im Laufe von fünf Jahren zu einem Open-Source-Projekt, das von Mozilla Research entwickelt wird und von einer großen Community von freiwilligen Mitwirkenden unterstützt wird. Traurigerweise ist die übliche Auffassung, dass man nicht alle gewünschten Eigenschaften in einer Programmiersprache haben kann. Sprachen wie Java bieten eine starke Typ- und Speichersicherheit und verhindern damit eine Vielzahl von Speicherfehlern, allerdings geht das auf Kosten der Ressourcenkontrolle. Infolgedessen besteht für viele Anwendungen zur Systemprogrammierung die einzige realistische Option darin, eine Sprache wie \texttt{C} oder \texttt{C++} zu verwenden, die zwar eine fein granulierte Kontrolle über die Speicherverwaltung bietet, jedoch ist diese Kontrolle mit hohen Kosten verbunden. Beispielsweise berichtete Microsoft kürzlich, dass 70\% der Sicherheitslücken, die sie beheben, auf Verletzungen der Speichersicherheit zurückzuführen sind, also genau die Art von Verletzungen, die bei starken Typsystemen ausgeschlossen werden sollten. Ebenso berichtet Mozilla, dass die überwiegende Mehrheit der kritischen Fehler, die sie in Firefox finden, speicherbezogen sind. Wenn es nur einen Weg gäbe, irgendwie das Beste aus beiden Welten zu vereinen, sodass eine sichere Systemprogrammiersprache entsteht, dann würde man versuchen, so eine Sprache wie Rust zu entwickeln. Rust enstand aus der Note heraus. Sie ist die erste von der Industrie unterstützte Programmiersprache, die den seit langem bestehenden Kompromiss im Entwurf von Programmiersprachen zwischen den Sicherheitsgarantien höherer Programmiersprachen (wie Java) und der Kontrolle über die Speicherverwaltung durch low-level-Programmiersprachen (wie \texttt{C} und \texttt{C++}) überwindet. Rust geht diese Herausforderung mit Hilfe eines starken, neuartigen Typsystems an, das auf den Ideen der Eigentümerschaft (Ownership) and des Ausleihen (Borrowing) basiert und die statische Mutation eines gemeinsamen Zustandes verbietet. Dieser Ansatz ermöglicht es, die üblichen Fallstricke der Systemprogrammierung wie Data Races zur Kompilierzeit zu erkennen und zu verhindern. 

Das Ownership-System legt für jeden Wert eine klare Lebensdauer fest, wodurch die Verwendung eines Garbage-Collectors überflüssig wird und solide, aber flexible Schnittstellen für die Verwaltung anderer Arten von Ressourcen wie Sockets und Datei-Handles ermöglicht werden. Durch \glqq Moves\grqq{} können Werte von einem Eigentümer auf einen anderen übertragen werden, und durch Ausleihen kann ein Code einen Wert vorübergehend verwenden, ohne dass sich dies auf das Eigentum auswirkt. 
Die Kontrolle über die Speicherverwaltung ist ein sehr wichtiger Aspekt der systemnahen Programmierung, besonders für Anwendungen wie Web-Browser, Betriebssysteme oder Game-Engines, bei denen Leistungs- oder Ressourcenbeschränkungen ein Hauptanliegen sind. Diese Art der Kontrolle wird von Rust unterstützt, womit die Möglichkeit gegeben wird, die Darstellung von Daten auf Byte-Ebene zu bestimmen sowie einen Zugang zum \glqq Bare Metal\grqq{} zu schaffen und die zeitliche und räumliche Nutzung von Programmen durch Low-Level-Programmiertechniken zu optimieren.
Es gibt eine Reihe von Datentypen, deren Implementierungen grundlegend vom gemeinsam veränderlichen Zustand (shared mutable state) abhängen und daher nicht nach der strengen Ownership-Prinzip von Rust typgeprüft werden können. Um solche Datentypen zu unterstützen, setzt Rust auf die vernünftige Verwendung von unsicheren Codes (engl. Unsafe Code), die in sicheren APIs gekapselt sind.
Diese Alleinstellungsmerkmale, über die nur Rust verfügt, sind wohl der Grund, warum Rust von Entwicklern in einer 2020 von der Stack Overflow durchgeführten Umfrage zum fünften Mal in Folge zur beliebtesten Programmiersprache gewählt wurde. 


