% !TEX root =  master.tex
\chapter{Zusammenfassung}

\nocite{*}

Dieses Kapitel enthält die Zusammenfassung der Arbeit mit Fazit und Ausblick.

\section{Fazit}

In dieser Arbeit wurde zunächst ein Überblick zu den unterschiedlichen Kernkonzepten und Besonderheiten der Programmiersprache Rust wie Ownership, Borrowing, Lifetimes und unsicheren Code gegeben. Rust ist die erste von der Industrie unterstützte Sprache, die den jahrzehntelangen Kompromiss im Programmiersprachenentwurf zwischen Speicherkontrolle und -sicherheit überwinden konnte. Sie ist sowohl eine typsichere Sprache als auch eine Systemprogrammiersprache. Sie bringt moderne Werkzeuge in den Bereich der Systemprogrammierung und hält den Ressourcenverbrauch niedrig, ohne hierbei, die Speichersicherheit zu beeinträchtigen.\autocite{rust-whitepaper-npm} Hierbei unterscheidet sich Rust von den anderen Sprachen, die die gleiche Garantie für Typsicherheit bieten, darin, dass sie dies ohne Garbage Collector oder manuelle Speicherverwaltung tut. 

Rust ist nicht wirklich eine objektorientierte Sprache, obwohl sie einige objektorientierte Merkmale aufweist. Sie ist keine funktionale Sprache, obwohl sie dazu neigt, die Einflüsse auf das Ergebnis einer Berechnung deutlicher zu machen, wie es funktionale Sprachen tun. Diese Vielfältigkeit macht Rust zu einem vielseitigen Alleskönner. 
Rust ist für Entwickler und Projekte gedacht, bei denen nicht nur Leistung und low-level-Optimierungen wichtig sind, sondern bei denen auch eine sichere und stabile Ausführungsumgebung benötigt wird. Rust fügt eine Menge funktionaler High-Level-Programmiertechniken innerhalb der Sprache hinzu, so dass sie sich gleichzeitig wie eine Low-Level- und eine High-Level-Sprache anfühlt. Rust ähnelt \texttt{C} und \texttt{C++} bis zu einem gewissen Grad, aber viele Idiome aus diesen Sprachen treffen eher nicht zu, so dass der typische Rust-Code \texttt{C}- oder \texttt{C++}-Code nicht sehr ähnlich ist. 

Rust ist für die Implementierung jener fundamentalen Softwarekomponenten konzipiert, die eine starke Leistung und eine umfassende Kontrolle über die Ressourcen erfordern, aber dennoch das grundlegende Niveau der Vorhersagbarkeit garantieren, das die Typsicherheit bietet. Dadurch wird Entwicklern möglich, die Kosten ihres Codes vorherzusehen.

Natürlich bringt Rust nicht nur Vorteile, sondern auch einige Nachteile mit sich, die Entwickler kennen sollten, bevor sie sich für oder gegen die Verwendung von Rust entscheiden. Dadurch, dass Rust eine relativ neue Programmiersprache ist, ist Ihr Ökosystem dementsprechend auch nicht alt genug, um alle für die Entwicklung benötigten Bibliotheken anzubieten. Folglich mangelt es an Bibliotheken allgemein bzw. an ausgereiften Bibliotheken. Dies führt dazu, dass die Effizienz bei der Entwicklung sich möglicherweise verringert. Zudem sind fehlende Industrie-Standards ein weiterer Nachteil von Rust. Die Unausgereiftheit der Sprache erschwert ebenfalls das Erlernen von Rust, da es viel weniger Literatur für Rust gibt als für vergleichbare, ältere Programmiersprachen.    


\section{Ausblick}

Rust löst die seit langem bestehende Spannung zwischen zwei bisher scheinbar unvereinbaren Wünschbarkeiten, nämlich Sicherheit und Kontrolle. Obwohl Rust-Compiler vor kurzem von Mozilla überarbeitet wurde, um eine schnellere Ausführung, schnellere Kompilierung und eine genauere Codeüberprüfung zu erreichen,\autocite{rust-language-doubles-down-speed} gibt es immer noch Best Practices und Werkzeuge, die verbessert werden könnten, damit Rust entwicklerfreundlicher wird. Der Erfolg von Rust ist auf langfristigen Erfolg ausgerichtet, denn Rust wie bereits erwähnt ist eine für die nächsten 40 Jahre entworfene Sprache.



